import { InternalMoveEnum, InternalMoveFunction, InternalMoveModule, InternalMoveStruct } from '../internal-models.js'
import path from 'path'
import fs from 'fs'
import { AccountModulesImportInfo, AccountRegister } from '../account.js'
import { format } from 'prettier'
import { isFrameworkAccount, moduleQname, normalizeToJSName, SPLITTER, VECTOR_STR } from '../utils.js'
import { TypeDescriptor } from '../types.js'
import { ChainAdapter } from '../chain-adapter.js'

interface OutputFile {
  fileName: string
  fileContent: string
}

interface Config {
  fileName: string
  outputDir: string
  // network: NetworkType
}

// TODO be able to generate cjs
export abstract class AbstractCodegen<ModuleTypes, StructType> {
  ADDRESS_TYPE: string
  SYSTEM_PACKAGE: string
  PREFIX: string
  STRUCT_FIELD_NAME: string = 'data'
  PAYLOAD_OPTIONAL = false
  SYSTEM_MODULES = new Set(['0x1', '0x2', '0x3', '0x4'])
  ESM = true

  chainAdapter: ChainAdapter<ModuleTypes, StructType>

  protected constructor(chainAdapter: ChainAdapter<ModuleTypes, StructType>) {
    this.chainAdapter = chainAdapter
  }

  public maybeEsmPrefix() {
    return this.ESM ? '.js' : ''
  }

  readModulesFile(fullPath: string) {
    return JSON.parse(fs.readFileSync(fullPath, 'utf-8'))
  }

  protected defaultCoderPackage() {
    return this.SYSTEM_PACKAGE
  }

  generateLoadAll(isSystem: boolean): string {
    return 'loadAllTypes(defaultMoveCoder())'
  }

  async generate(
    srcDir: string,
    outputDir: string,
    // network: NetworkType,
    builtin = false
  ) {
    if (!fs.existsSync(srcDir)) {
      return 0
    }

    const files = fs.readdirSync(srcDir)
    outputDir = path.resolve(outputDir)
    const outputs: OutputFile[] = []

    fs.mkdirSync(outputDir, { recursive: true })

    const loader = new AccountRegister()

    // when generating user code, don't need to generate framework account
    for (const sysModule of this.SYSTEM_MODULES) {
      loader.accountImports.set(sysModule, new AccountModulesImportInfo(sysModule, sysModule))
    }
    // const client = getRpcClient(network)

    for (const file of files) {
      if (!file.endsWith('.json')) {
        continue
      }
      const fullPath = path.resolve(srcDir, file)
      const abi = this.readModulesFile(fullPath)
      const modules = this.chainAdapter.toInternalModules(abi)

      for (const module of modules) {
        loader.register(module, path.basename(file, '.json'))
      }

      const fileName = path.basename(file, '.json')
      // TODO more reliable way to check if this is sui address
      const address = fileName.startsWith('0x') ? fileName : undefined

      const codeGen = new AccountCodegen(
        this,
        loader,
        abi,
        modules,
        {
          fileName,
          outputDir: outputDir
          // network,
        },
        address
      )

      outputs.push(...codeGen.generate())
    }

    while (loader.pendingAccounts.size > 0) {
      for (const account of loader.pendingAccounts) {
        const id = await this.chainAdapter.getChainId()
        console.log(`download dependent module for account ${account}, chain ID: ${id}`)

        try {
          const rawModules = await this.chainAdapter.fetchModules(
            account
            // network
          )
          const modules = this.chainAdapter.toInternalModules(rawModules)

          fs.writeFileSync(path.resolve(srcDir, account + '.json'), JSON.stringify(rawModules, null, '\t'))
          for (const module of modules) {
            loader.register(module, account)
          }
          const codeGen = new AccountCodegen(
            this,
            loader,
            rawModules,
            modules,
            {
              fileName: account,
              outputDir: outputDir
              // network,
            },
            account
          )

          outputs.push(...codeGen.generate())
        } catch (e) {
          console.error(
            'Error downloading account module, check if you choose the right networkï¼Œor download account modules manually into your director'
          )
          console.error(e)
          process.exit(1)
        }
      }
    }

    for (const output of outputs) {
      let content = output.fileContent
      content = await format(output.fileContent, { parser: 'typescript' })
      fs.writeFileSync(path.join(outputDir, output.fileName), content)
    }

    const rootFile = path.join(outputDir, 'index.ts')
    let rootFileContent = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
`
    for (const output of outputs) {
      const parsed = path.parse(output.fileName)
      rootFileContent += `export * as _${parsed.name.replaceAll('-', '_')} from './${
        parsed.name
      }${this.maybeEsmPrefix()}'\n`
    }
    fs.writeFileSync(rootFile, rootFileContent)

    return outputs.length
  }

  protected generateExtra(address: string | undefined, module: InternalMoveModule) {
    return ''
  }

  generateModule(
    module: InternalMoveModule,
    allEventStructs: Map<string, InternalMoveStruct>,
    addressOverride?: string
    // network: NetworkType
  ) {
    const qname = moduleQname(module)
    const eventStructs = new Map<string, InternalMoveStruct>()
    for (const [type, struct] of allEventStructs.entries()) {
      if (type.startsWith(qname + SPLITTER)) {
        eventStructs.set(type, struct)
      }
    }

    const eventTypes = new Set(eventStructs.keys())
    const events = Array.from(eventStructs.values())
      .map((e) => this.generateForEvents(module, e))
      .filter((s) => s !== '')
    const enums = module.enums.map((e) => this.generateEnum(module, e))
    const structs = module.structs.map((s) => this.generateStructs(module, s, eventTypes))
    const callArgs = module.exposedFunctions.map((f) => this.generateCallArgsStructs(module, f))

    const moduleName = normalizeToJSName(module.name)
    return `

  export namespace ${moduleName} {
    ${enums.join('\n')}
  
    ${structs.join('\n')}
    
    ${this.generateExtra(addressOverride, module)}
    
    ${events.join('\n')}
    
    ${callArgs.join('\n')}
  }
  `
  }

  generateEnum(module: InternalMoveModule, enumType: InternalMoveEnum): string {
    const enumName = normalizeToJSName(enumType.name)
    const enumValues = Object.keys(enumType.variants)
      .map((v) => `'${v}'`)
      .join(' | ')

    const typeParams = enumType.typeParams || []
    const genericString = this.generateStructTypeParameters(enumType)
    const genericStringAny = this.generateStructTypeParameters(enumType, true)

    const typeParamApplyArg = typeParams
      .map((v, idx) => {
        return `arg${idx}: TypeDescriptor<T${idx}> = ANY_TYPE`
      })
      .join(',')
    const typeParamApply = typeParams
      .map((v, idx) => {
        return `arg${idx}`
      })
      .join(',')

    const typeDescriptor = `
  export namespace ${enumName}{
    export const TYPE_QNAME = '${module.address}::${module.name}::${enumType.name}'
    
    const TYPE = new TypeDescriptor<${enumName}${genericStringAny}>(${enumName}.TYPE_QNAME)

    export function type${genericString}(${typeParamApplyArg}): TypeDescriptor<${enumName}${genericString}> {
      return TYPE.apply(${typeParamApply})
    }
  }
`
    // TODO support fields
    return `
  export interface ${enumName} {
    fields: {}
    variant: ${enumValues}
  }

  ${typeDescriptor}
  `
  }

  generateStructs(module: InternalMoveModule, struct: InternalMoveStruct, events: Set<string>, typeOnly = false) {
    const typeParams = struct.typeParams || []
    const genericString = this.generateStructTypeParameters(struct)
    const genericStringAny = this.generateStructTypeParameters(struct, true)

    const structName = normalizeToJSName(struct.name)

    const fields = struct.fields.map((field) => {
      const type = this.generateTypeForDescriptor(field.type, module.address)
      return `${field.name}: ${type}`
    })

    const typeParamApplyArg = typeParams
      .map((v, idx) => {
        return `arg${idx}: TypeDescriptor<T${idx}> = ANY_TYPE`
      })
      .join(',')
    const typeParamApply = typeParams
      .map((v, idx) => {
        return `arg${idx}`
      })
      .join(',')

    const typeDescriptor = `
  export namespace ${structName}{
    export const TYPE_QNAME = '${module.address}::${module.name}::${struct.name}'
    
    const TYPE = new TypeDescriptor<${structName}${genericStringAny}>(${structName}.TYPE_QNAME)

    export function type${genericString}(${typeParamApplyArg}): TypeDescriptor<${structName}${genericString}> {
      return TYPE.apply(${typeParamApply})
    }
  }
`
    if (typeOnly) {
      return typeDescriptor
    }

    let eventPayload = ''
    if (events.has(moduleQname(module) + SPLITTER + struct.name)) {
      eventPayload = `
    export type ${structName}Instance = TypedEventInstance<${structName}${genericStringAny}> & {
      ${this.STRUCT_FIELD_NAME}_decoded: ${structName}${genericStringAny}
      type_arguments: [${struct.typeParams.map((_) => 'string').join(', ')}]
    }
    `
    }

    return `
  export interface ${structName}${genericString} {
    ${fields.join('\n')}
  }
  
  ${typeDescriptor}

  ${eventPayload}
  `
  }

  generateFunctionTypeParameters(func: InternalMoveFunction) {
    let genericString = ''
    if (func.typeParams && func.typeParams.length > 0) {
      const params = func.typeParams
        .map((v, idx) => {
          return `T${idx}=any`
        })
        .join(',')
      genericString = `<${params}>`
    }
    return genericString
  }

  generateFunctionReturnTypeParameters(func: InternalMoveFunction, currentAddress: string) {
    let returnType = ''
    if (func.return && func.return.length > 0) {
      returnType = func.return
        .map((v, idx) => {
          return this.generateTypeForDescriptor(v, currentAddress)
        })
        .join(',')
    }
    return '[' + returnType + ']'
  }

  generateStructTypeParameters(struct: InternalMoveStruct | InternalMoveEnum, useAny = false) {
    let genericString = ''

    if (struct.typeParams && struct.typeParams.length > 0) {
      const params = struct.typeParams
        .map((v, idx) => {
          return useAny ? 'any' : 'T' + idx
        })
        .join(',')
      genericString = `<${params}>`
    }
    return genericString
  }

  // generateTypeParameters(struct: TypeDescriptor, useAny = false) {
  //   let genericString = ''
  //
  //   if (struct.typeArgs && struct.typeArgs.length > 0) {
  //     const params = struct.typeArgs
  //         .map((_, idx) => {
  //           return useAny ? 'any' : 'T' + idx
  //         })
  //         .join(',')
  //     genericString = `<${params}>`
  //   }
  //   return genericString
  // }

  generateCallArgsStructs(module: InternalMoveModule, func: InternalMoveFunction) {
    return ''
  }

  generateForEvents(module: InternalMoveModule, struct: InternalMoveStruct): string {
    return ''
  }

  generateTypeForDescriptor(type: TypeDescriptor, currentAddress: string): string {
    if (type.reference) {
      return this.ADDRESS_TYPE
    }

    switch (type.qname) {
      case 'signer': // TODO check this
      case 'address':
      case 'Address':
        return this.ADDRESS_TYPE
      case '0x1::string::String':
        return 'string'
      case 'bool':
      case 'Bool':
        return 'boolean'
      case 'u8':
      case 'U8':
      case 'u16':
      case 'U16':
      case 'u32':
      case 'U32':
        return 'number'
      case 'u64':
      case 'U64':
      case 'u128':
      case 'U128':
      case 'u256':
      case 'U256':
        return 'bigint'
    }

    if (type.qname.toLowerCase() === VECTOR_STR) {
      // vector<u8> as hex string
      const elementTypeQname = type.typeArgs[0].qname
      if (elementTypeQname === 'u8') {
        // only for aptos
        return 'string'
      }
      // if (elementTypeQname.startsWith('T') && !elementTypeQname.includes(SPLITTER)) {
      //   return  `${elementTypeQname} extends string ? string : ${elementTypeQname}[]`
      // }
      // TODO there might be an error here, find the case and get it fixed
      if (elementTypeQname.startsWith('T') && !elementTypeQname.includes(SPLITTER)) {
        return `${elementTypeQname}[]`
      }
      return this.generateTypeForDescriptor(type.typeArgs[0], currentAddress) + '[]'
    }

    const simpleName = this.generateSimpleType(type.qname, currentAddress)
    if (simpleName.length === 0) {
      console.error('unexpected error')
    }
    if (simpleName.toLowerCase() === VECTOR_STR || simpleName.toLowerCase().startsWith(VECTOR_STR + SPLITTER)) {
      console.error('unexpected vector type error')
    }
    if (type.typeArgs.length > 0) {
      // return simpleName
      return (
        simpleName + '<' + type.typeArgs.map((t) => this.generateTypeForDescriptor(t, currentAddress)).join(',') + '>'
      )
    }
    return simpleName
  }

  generateSimpleType(type: string, currentAddress: string): string {
    const parts = type.split(SPLITTER)

    for (let i = 0; i < parts.length; i++) {
      parts[i] = normalizeToJSName(parts[i])
    }

    if (parts.length < 2) {
      return parts[0]
    }
    if (parts[0] === currentAddress) {
      return parts.slice(1).join('.')
    }
    return '_' + parts.join('.')
  }

  generateImports() {
    // let refImports = `import { ${this.ADDRESS_TYPE} } from "${this.SYSTEM_PACKAGE}"`
    // if (this.ADDRESS_TYPE === 'string') {
    //   refImports = ''
    // }

    const imports = `
    import { TypeDescriptor, ANY_TYPE } from "@typemove/move"
    import {
      MoveCoder, TypedEventInstance } from "@typemove/${this.PREFIX.toLowerCase()}"
      
    import { defaultMoveCoder } from "${this.defaultCoderPackage()}"

    `
    return imports
  }
}

export class AccountCodegen<ModuleType, StructType> {
  modules: InternalMoveModule[]
  config: Config
  abi: ModuleType[]
  loader: AccountRegister
  moduleGen: AbstractCodegen<ModuleType, StructType>
  // Usually it's same as module.address, but in upgraded package, this might be the new address
  address?: string

  constructor(
    moduleGen: AbstractCodegen<ModuleType, StructType>,
    loader: AccountRegister,
    abi: ModuleType[],
    modules: InternalMoveModule[],
    config: Config,
    address: string | undefined
  ) {
    // const json = fs.readFileSync(config.srcFile, 'utf-8')
    this.moduleGen = moduleGen
    this.abi = abi
    this.modules = modules
    this.config = config
    this.loader = loader
    this.address = address
  }

  generate(): OutputFile[] {
    if (!this.modules) {
      return []
    }
    // const baseName = path.basename(this.config.fileName, '.json')

    let address: string | undefined
    for (const module of this.modules) {
      address = module.address
    }
    if (!address) {
      return []
    }

    const dependedAccounts: string[] = []

    const moduleImports: string[] = []

    const info = this.loader.accountImports.get(address)

    if (info) {
      for (const [account] of info.imports.entries()) {
        // Remap to user's filename if possible, TODO codepath not well tested
        const tsAccountModule = './' + (this.loader.accountImports.get(account)?.moduleName || account)
        if (isFrameworkAccount(account) && !isFrameworkAccount(address)) {
          // Decide where to find builtin library
          moduleImports.push(
            `import * as _${account} from "${this.moduleGen.SYSTEM_PACKAGE}/builtin/${account}"`
            // `import _${account} = builtin._${account} `
          )
        } else {
          moduleImports.push(`import * as _${account} from "${tsAccountModule}${this.moduleGen.maybeEsmPrefix()}"`)
        }

        dependedAccounts.push(account)
      }
      for (const friend of info.friends) {
        // shouldn't import self
        if (!this.modules.find((m) => m.name === friend)) {
          moduleImports.push(`import { ${friend} } from "./${friend}${this.moduleGen.maybeEsmPrefix()}"`)
        }
      }
    }

    const eventsMap: Map<string, InternalMoveStruct> = this.moduleGen.chainAdapter.getAllEventStructs(this.modules)

    const source = `
    /* Autogenerated file. Do not edit manually. */
    /* tslint:disable */
    /* eslint-disable */

    /* Generated types for ${this.address || address}, original address ${address} */

    ${this.moduleGen.generateImports()}

    ${moduleImports.join('\n')}

    ${this.modules.map((m) => this.moduleGen.generateModule(m, eventsMap, this.address)).join('\n')}

    const MODULES = JSON.parse('${JSON.stringify(this.abi)}')

    export function loadAllTypes(coder: MoveCoder) {
      ${dependedAccounts.map((a) => `_${a}.loadAllTypes(coder)`).join('\n')}
      for (const m of Object.values(MODULES)) {
        coder.load(m as any, '${address}')
      }
    }
    
    ${this.moduleGen.generateLoadAll(this.moduleGen.SYSTEM_MODULES.has(address))}
    ` // source

    return [
      {
        fileName: this.config.fileName + '.ts',
        fileContent: source
      }
    ]
  }
}
